{"meta":{"title":"张峻滔的空间","subtitle":null,"description":null,"author":"Zhang Juntao","url":"http://zhangjuntao.com.cn"},"pages":[{"title":"About","date":"2018-01-21T13:31:15.508Z","updated":"2017-05-17T14:48:07.779Z","comments":false,"path":"about/index.html","permalink":"http://zhangjuntao.com.cn/about/index.html","excerpt":"","text":"about: type: meicon: icon-usertext_value: “中国矿业大学（北京）” “1992 重庆” “HTML / CSS / JavaScript / jQuery / zepto/ less / sass / gulp / webpack / Vue.js” type: Githubicon: icon-githubtext_key: Githubtext_value: “@Jtrust”text_value_url: https://github.com/Jtrust type: mailicon: icon-mailtext_key: E-mailtext_value: “jtarch@163.com” type: locationicon: icon-locationtext_value: 成都"},{"title":"Category","date":"2018-01-21T13:31:15.493Z","updated":"2017-05-17T09:14:46.866Z","comments":false,"path":"category/index.html","permalink":"http://zhangjuntao.com.cn/category/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-01-21T13:31:15.481Z","updated":"2017-05-18T08:40:18.651Z","comments":false,"path":"project/index.html","permalink":"http://zhangjuntao.com.cn/project/index.html","excerpt":"","text":""},{"title":"Tag","date":"2018-01-21T13:31:15.466Z","updated":"2017-05-17T09:15:56.490Z","comments":false,"path":"tag/index.html","permalink":"http://zhangjuntao.com.cn/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Js中常用的设计模式","slug":"js中常用的设计模式","date":"2018-01-29T02:12:33.000Z","updated":"2018-01-29T07:11:37.954Z","comments":true,"path":"2018/01/29/js中常用的设计模式/","link":"","permalink":"http://zhangjuntao.com.cn/2018/01/29/js中常用的设计模式/","excerpt":"","text":"模式的起源模式并非起源于软件工程行业，而是建筑学领域。模式的研究起源于建筑设计大师Christopher Alexander关于城市规划和建筑设计的著作。但尽管著作针对建筑学领域，但实际上适用于所有的工程设计领域，包括软件开发设计领域。 亚历山大在《建筑的永恒之道》里这样描述：模式是一条由三个部分组成的通用规则：它表示了一个特定环境、一类问题和一个解决方案之间的关系。每一个模式描述了一个不断重复发生的问题，以及该问题解决方案的核心设计。 在他的另一本书《建筑模式语言》中提到了现在已经定义了253种模式。比如：说明城市主要的结构：亚文化区的镶嵌、分散的工作点、城市的魅力、地方交通区住宅团组：户型混合、公共性的程度、住宅团组、联排式住宅、丘状住宅、老人天地室内环境和室外环境、阴和阳总是一气呵成针对住宅：夫妻的领域、儿童的领域、朝东的卧室、农家的厨房、私家的沿街露台、个人居室、起居空间的序列、多床卧室、浴室、大储藏室 1987年，Ward Cunninghan和Kent Beck在一起用Smalltalk做设计用户界面的工作。他们决定使用Alexander的理论发展一个有五个模式的语言来指导Smalltalk的新手，因此，《Using Pattern Languages for Object-Oriented Programs》论文发表。Ward Cunninghan和Kent Beck是对设计模式的发展影响最大的先行者。 第一个也是可以说是在软件工程设计模式中出版的最具代表性的最具代表性的正式作品之一，是1994年的一本书《Design Patterns》，称为设计模式。这是由Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides撰写的，该团体被称为“四人组”（或简称GoF）。有兴趣的话大家可以看一下这篇文章 模式的简史和形而上学 设计模式的作用 [ 开发 ]开发效率高利于团队协作 [ 维护 ]有利于代码的升级改版逻辑清晰，代码严谨，利于后期的维护 [ 通用 ]我们依托设计模式可以实现组件化、模块化、插件化、框架化以及一些常用类库方法的编写 JS中常用的设计模式 单例设计模式、构造-原型设计模式、发布订阅设计模式… 单例设计模式123456789101112131415//单例模式：把实现当前这个模块所有的属性和方法汇总到同一个命名空间下（分组作用，避免了全局变量的污染）var app=(function()&#123; //实现当前模块具体业务逻辑的方法全部存放在闭包中 var fn=function()&#123; //... &#125; return &#123; init:function()&#123; //入口方法：控制当前模块具体的业务逻辑顺序 fn(); &#125; &#125;&#125;)();app.init(); 单体模式的优点是： 可以用来划分命名空间，减少全局变量的数量。 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。 可以被实例化，且实例化一次。 构造原型模式：最贴近OOP面向对象编程思想的 封装类库、插件或者UI组件，基本上都是基于构造原型模式来开发的1234567891011121314151617181920212223242526class Tool&#123; constructor()&#123; this.isCompatible='addEventListener' in document;//=&gt;如果不兼容返回FALSE(IE6~8) &#125; //=&gt;挂载到原型上的方法 css()&#123; //... &#125; //=&gt;挂载到普通对象上的方法 static distinct()&#123; //... &#125;&#125;class Banner extends Tool&#123; constructor(...arg)&#123; super(); this.xxx=xxx; &#125; //挂载到子类原型上的方法 bindData()&#123; this.css();//=&gt;把父类原型上的方法执行（子类继承了父类，那么子类的实例就可以调取父类原型上的方法了） this.distinct===undefined;//子类的实例只能调取父类原型上的方法和父类给实例提供的私有属性方法，但是父类做为普通对象加入的静态方法，子类的实例是无法调取的 (只有这样才可以调取使用：Tool.distinct()) &#125;&#125; 我有三个类 A/B/C ，我想让C继承A和B123456789class A&#123; ...&#125;class B extends A&#123; ...&#125;class C extends B&#123; ...&#125; 发布订阅设计模式 俗称叫做“观察者模式”不同于单例和构造，发布订阅是小型设计模式，应用到某一个具体的需求中：凡是当到达某个条件之后要执行N多方法，我们都可以依托于发布订阅设计模式管理和规划我们的JS代码 实现思路和原理：1、我们先创建一个计划表（容器）2、后期需要做什么事情，我们都依次把需要处理的事情增加到计划表中3、当符合某个条件的时候，我们只需要通知计划表中的方法按照顺序依次执行即可 JQ中的发布订阅 JQ中提供了实现发布订阅设计模式的方法123456789101112131415161718192021222324$(function () &#123; // 将被添加到列表的一个简单的函数 var foo = function( value ) &#123; alert( \"foo:\" + value ); &#125;; var callbacks = $.Callbacks(); // 添加函数 \"foo\" 到列表 callbacks.add( foo ); // 传入参数调用所有回调列表 callbacks.fire( \"hello\" ); // 输出: \"foo: hello\" callbacks.fire( \"world\" ); // 输出: \"foo: world\" // 添加另一个函数到列表 var bar = function( value ,x)&#123; alert( \"bar:\" + value +x); &#125;; // 添加这个函数到列表 callbacks.add( bar ); // callbacks.remove(fn);//=&gt;移除方法 // 传入参数调用所有回调列表(按照顺序执行),\"hello again\",666 会分别作为实参传递给每一个需要执行的方法 callbacks.fire( \"hello again\",666 ); // 输出: // \"foo: hello again\" // \"bar: hello again666\"&#125;) 实现一个发布订阅1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var Event = (function() &#123; var clientList = &#123;&#125;; var add, fire, remove; add = function(key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; fire = function() &#123; var key = [].shift.call(arguments); var fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function(key, fn) &#123; var fns = clientList[key]; // key对应的消息么有被人订阅 if (!fns) &#123; return false; &#125; // 没有传入fn(具体的回调函数), 表示取消key对应的所有订阅 if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; // 反向遍历 for (var i = fns.length - 1; i &gt;= 0; i--) &#123; var _fn = fns[i]; if (_fn === fn) &#123; // 删除订阅回调函数 fns.splice(i, 1); &#125; &#125; &#125; &#125;; return &#123; add: add, fire: fire, remove: remove &#125;&#125;()); var fn1 = function(a) &#123; console.log(a);&#125;; var fn2 = function(a)&#123; console.log(a+'fn2');&#125;;var fn3 = function(a)&#123; console.log(a+'fn3');&#125;;Event.add(\"commit\", fn1) //订阅触发某状态时需要执行的函数Event.add(\"commit\", fn2)Event.remove(\"commit\", fn2)//删除Event.add(\"commit\", fn3)Event.fire(\"commit\",10); //触发执行","categories":[{"name":"js","slug":"js","permalink":"http://zhangjuntao.com.cn/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhangjuntao.com.cn/tags/设计模式/"}]},{"title":"Redux基本用发","slug":"redux基本用发","date":"2018-01-21T08:51:49.000Z","updated":"2018-01-29T06:57:43.185Z","comments":true,"path":"2018/01/21/redux基本用发/","link":"","permalink":"http://zhangjuntao.com.cn/2018/01/21/redux基本用发/","excerpt":"","text":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 是怎么做到可预测的呢？ 单一数据源，单一状态树，state State 是只读的。所有数据都是只读的，要想修改数据，必须 dispatch 一个 action 来描述什么发生了改变。这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图 使用纯函数来执行修改。纯函数的返回值只由它调用时的参数决定，它的执行不依赖于系统的状态（比如：何时、何处调用它）。Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state工作流程 需要改变状态时，现派发一个动作 1store.dispatch(action); Reducer匹配action类型，返回新的state 123456789function reducer(state=&#123;xx:xx&#125;,action) &#123; switch (action.type)&#123; case 'xxx': return &#123;新的state&#125;; case 'xxx': return &#123;新的state&#125;; &#125; return state;&#125; State 一旦有变化，Store 就会调用监听函数。 123//通常在componentDidMount函数里设置监听函数//订阅 每次dispatch后更新状态store.subscribe(() =&gt; &#123;this.setState(&#123;n:store.getState().number&#125;) 直接看一个简单的例子 index.js 1234import React from 'react'import ReactDOM from 'react-dom';import Counter from './Counter'ReactDOM.render(&lt;Counter/&gt;, window.root) store.js 123456789101112import &#123;createStore&#125; from 'redux';function reducer(state = &#123;number: 0&#125;, action) &#123; //可以给state设置初始值 switch (action.type) &#123; case 'ADD': //ADD、MINUS是提前定义好的各种action return &#123;number: state.number + action.count&#125;; //匹配action中的type，返回新的state case 'MINUS': return &#123;number: state.number - action.count&#125;; default: return state; &#125;&#125;export default createStore(reducer); //创建一个状态树 Counter.js 1234567891011121314151617181920212223242526272829import React from 'react';import store from './store.js';// 组件更新 属性的更新 更新状态 ,将redux中的数据转化成自己的状态export default class Counter extends React.Component &#123; constructor()&#123; super(); console.log(store.getState()); this.state = &#123;n:store.getState().number&#125; //store.getState() 拿到store里的state &#125; componentDidMount()&#123; this.un = store.subscribe(() =&gt; &#123; //订阅 每次dispatch后更新状态 this.setState(&#123;n:store.getState().number&#125;) &#125;) &#125; componentWillUnmount()&#123; //组件销毁时 需要将其监听的函数移除掉 this.un(); &#125; render()&#123; return &lt;div&gt; &lt;button onClick=&#123;()=&gt;&#123; //每次dispatch后都需要重新更新状态=&gt;subscribe store.dispatch(&#123;type:'ADD',count:1&#125;) //提交带有type属性的action &#125;&#125;&gt;+&lt;/button&gt; &lt;span&gt;&#123;this.state.n&#125;&lt;/span&gt; &lt;button onClick=&#123;()=&gt;&#123; store.dispatch(&#123;type:'MINUS',count:1&#125;) &#125;&#125;&gt;-&lt;/button&gt; &lt;/div&gt; &#125;&#125;","categories":[{"name":"redux","slug":"redux","permalink":"http://zhangjuntao.com.cn/categories/redux/"}],"tags":[{"name":"react redux","slug":"react-redux","permalink":"http://zhangjuntao.com.cn/tags/react-redux/"}]},{"title":"Express的基础语法","slug":"Express的基础语法","date":"2018-01-08T04:12:16.000Z","updated":"2018-01-21T14:58:52.643Z","comments":true,"path":"2018/01/08/Express的基础语法/","link":"","permalink":"http://zhangjuntao.com.cn/2018/01/08/Express的基础语法/","excerpt":"","text":"express是node的一个框架，我们可以基于express快速搭建一个web服务，并且提供一些供客户端调用的api接口（支持中间件、支持路由处理等）；还有一个框架和它类似，叫做koa. 学习Express：http://www.expressjs.com.cn/4x/api.html 安装Express如果当前电脑已经安装了yarn，我们可以基于yarn安装express及相关配套插件12345678yarn init -y 生成package.json文件/* * express：express核心框架 * body-parser：用来快速解析请求主体中内容的 * express-session / cookie-parser：方便我们在express中操作session的 */yarn add express body-parser express-session cookie-parser 创建服务，监听端口基于NODE内置模块，使用原生JS代码实现WEB服务123456789101112131415let http = require('http'), fs = require('fs'), url = require('url');http.createServer((req, res)=&gt; &#123; let &#123;url:reqURL, method, headers&#125;=req, &#123;pathname, query&#125;=url.parse(reqURL, true); if (pathname === '/getMatchList' &amp;&amp; method=='GET') &#123; &#125; if(pathname==='/reg' &amp;&amp; method=='POST')&#123; &#125;&#125;).listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;); 基于express框架完成 express就是把我们自己用原生写的封装好了，我们以后直接调取使用即可（方便开发，有点类似于JQ）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);app.get(`/getMatchList`, (req, res)=&gt; &#123; //=&gt;等价于原生 //req.url 请求的地址+问号传参 //req.method 请求的方式(大写) //req.headers 请求头(小写) //=&gt;EXPRESS新提供的 //req.path 相当于我们原生中通过URL内置模块的PARSE方法解析出来的PATH-NAME //req.query 相当于解析出来的QUERY //=&gt;等价于原生 //res.writeHead 重写响应头 //res.write 响应主体 //res.end 结束响应(响应主体) /* res.writeHead(200, &#123; 'content-type': 'application/json' &#125;); res.end(JSON.stringify(&#123;\"id\": 1, \"name\": \"zf \"&#125;));//=&gt;只能返回字符串或者Buffer格式数据 //--------- fs.readFile('./index.html',(err,data)=&gt;&#123; if(err) return; res.writeHead(200,&#123; 'content-type':'text/html' &#125;); res.end(data); &#125;); //=&gt;好麻烦 */ //=&gt;EXPRESS独有的 //res.sendFile('./index.html',&#123;root:__dirname&#125;); 读取指定的文件，并且把内容响应给客户端 //res.json(&#123;\"id\":1,\"name\":\"zf\"&#125;); 我们可以直接放JSON,EXPRESS帮我们把它转换为字符串返回给客户端（并且设置好了响应头信息） //res.send() 综合体 //res.statusCode = 200; 设置状态码 //res.redirect() 重定向(对应状态码中的302/301) //res.sendStatus(404); 返回状态码并且附带一些状态码的描述信息 //...&#125;);app.post(`/reg`, (req, res)=&gt; &#123;&#125;); Express中间件 使用中间件的两大作用：1、想要提取部分公共代码2、想要在主体API逻辑处理前，做一些特殊处理（把传递的参数做特殊的处理）…123456789101112131415161718192021222324252627let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;所有的客户端请求都会先执行这个中间件(然后执行NEXT后在进入下一个处理程序)app.use((req, res, next)=&gt; &#123; //next:执行下一个处理(当前这个中间件根据情况，如果需要走到下一个操作，必须执行NEXT，如果不需要，直接响应内容即可) if (req.query.name) &#123; req.userName = req.query.name;//=&gt;把获取的内容写在了userName自定义属性上 next(); &#125; else &#123; res.send(`name必须传递`); &#125;&#125;);//=&gt;只有请求的地址中包含`/user`的才会进入这个中间件app.use(`/user`, (req, res, next)=&gt; &#123; req.userName += '@'; next();&#125;);app.get(`/user`, (req, res)=&gt; &#123; res.send(`My name is $&#123;req.userName&#125;`);&#125;);app.get(`/article`, (req, res)=&gt; &#123; res.send(`Article author is $&#123;req.userName&#125;`);&#125;); Express中的路由router 在真实项目中，我们为了有效的管理接口，我们会把相同功能体系的接口进行归类；在实现的时候，也会分类实现（分组管理）； 例如：/user/signin/user/signup /product/query/product/search /log/info GET获取 POST请求设置 同一个地址，因为请求方式不一样，实现不一样的功能… 此类操作，我们可以基于Express中的路由来完成 1、我们创建一个routers文件夹，在这个文件夹中存储所有功能模块的接口信息（分类存储） 2、在每一个路由模块中完成API接口的编写（举例：user模块）12345678910111213let express = require('express'), router = express.Router();//=&gt;router和app其实差不多router.use((req, res, next)=&gt; &#123; console.log(`ok`); next();&#125;);router.post(`/signin`, (req, res)=&gt; &#123; res.send('login success');&#125;);router.post(`/signup`, (req, res)=&gt; &#123; res.send('register success');&#125;);module.exports = router;//=&gt;把创建的路由导出,方便后续调取使用 3、在server中需要调取使用1234let express = require('express'), app = express();...app.use(`/user`, require('./routers/user')); Express中获取客户端传递的信息 客户端把信息传递给服务器：1、问号传参（GET请求）2、设置请求主体（POST请求）3、设置请求头（cookie等信息传送）… 问号传参 &amp; 请求头12345app.get(`/query`, (req, res)=&gt; &#123; console.log(req.headers);//=&gt;通过REQ的HEADERS可以直接的获取请求头信息(想获取其中的某一个:REQ.HEADERS.HOST...) res.send(req.query);//=&gt;通过REQ中的QUERY就可以获取问号传递的参数值(并且存储的方式是KEY:VALUE)&#125;); 请求主体123456789101112131415161718192021//=&gt;基于传统的内置模块自己实现app.use(`/reg`, (req, res, next)=&gt; &#123; //=&gt;POST请求获取请求主体内容,需要基于事件完成 let str = ``; req.on('data', chunk=&gt; &#123; //=&gt;正在接收请求主体中的内容(一般内容偏多) str += chunk; &#125;); req.on('end', ()=&gt; &#123; //=&gt;接收结束,此时STR存储的就是传递进来的信息 //=&gt;客户端传递给服务器的信息一般都是字符串格式的(JSON字符串或者普通的FORMAT-DATA字符串[xxx=xxx&amp;xxx=xxx]) //=&gt;真实项目中我们还要把字符串转化为对象方式(方便操作) let data = require('querystring').parse(str);//=&gt;这个内置模块就是把FORMAT-DATA变为对象键值对的方式存储 req.body = data;//=&gt;把解析后的数据放到REQ的自定义属性上,在其它的方法中可以获取使用 next(); &#125;);&#125;);app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;); 这种方式太麻烦了，我们可以使用第三方插件搞定刚才处理的事情：body-parser12345678let bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(bodyParser.json());app.use(bodyParser.raw());app.use(bodyParser.text());app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;); Express中静态文件的处理 基于express.static方法即可完成12345678910111213141516171819202122232425let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;真实项目中,我们一般都静态资源文件(HTML/CSS/JS/IMG...)存放在DIST或者LIB或者PUBLIC或者BUILD等指定的文件夹中app.use(express.static('dist'));//=&gt;大体实现原理let fs = require('fs'), path = require('path');let expressStatic = p=&gt; (req, res, next)=&gt; &#123; let pathname = path.join(`$&#123;__dirname&#125;/$&#123;p&#125;`, req.path); fs.readFile(pathname, (err, data)=&gt; &#123; if (err) &#123; //=&gt;找不到指定的文件 next(); &#125; else &#123; //=&gt;找到文件 res.sendFile(pathname); &#125; &#125;);&#125;;app.use(expressStatic('dist'));","categories":[{"name":"Express","slug":"Express","permalink":"http://zhangjuntao.com.cn/categories/Express/"}],"tags":[{"name":"Express NODE","slug":"Express-NODE","permalink":"http://zhangjuntao.com.cn/tags/Express-NODE/"}]}]}