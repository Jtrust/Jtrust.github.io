{"meta":{"title":"张峻滔的空间","subtitle":null,"description":null,"author":"Zhang Juntao","url":"http://jtao.pro","root":"/"},"pages":[{"title":"About","date":"2019-03-08T00:38:39.661Z","updated":"2017-05-17T14:48:07.779Z","comments":false,"path":"about/index.html","permalink":"http://jtao.pro/about/index.html","excerpt":"","text":"about: type: meicon: icon-usertext_value: “中国矿业大学（北京）” “1992 重庆” “HTML / CSS / JavaScript / jQuery / zepto/ less / sass / gulp / webpack / Vue.js” type: Githubicon: icon-githubtext_key: Githubtext_value: “@Jtrust”text_value_url: https://github.com/Jtrust type: mailicon: icon-mailtext_key: E-mailtext_value: “jtarch@163.com“ type: locationicon: icon-locationtext_value: 成都"},{"title":"Category","date":"2019-03-08T00:38:39.667Z","updated":"2017-05-17T09:14:46.866Z","comments":false,"path":"category/index.html","permalink":"http://jtao.pro/category/index.html","excerpt":"","text":""},{"title":"Project","date":"2019-03-08T00:38:39.673Z","updated":"2017-05-18T08:40:18.651Z","comments":false,"path":"project/index.html","permalink":"http://jtao.pro/project/index.html","excerpt":"","text":""},{"title":"Tag","date":"2019-03-08T00:38:39.680Z","updated":"2017-05-17T09:15:56.490Z","comments":false,"path":"tag/index.html","permalink":"http://jtao.pro/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack4.x打包优化","slug":"webpack4-x打包优化","date":"2019-03-11T14:17:49.000Z","updated":"2019-03-13T15:14:57.635Z","comments":true,"path":"2019/03/11/webpack4-x打包优化/","link":"","permalink":"http://jtao.pro/2019/03/11/webpack4-x打包优化/","excerpt":"","text":"区分生产环境和开发环境在开发环境中，我们需要：强大的 source map 和一个有着 live reloading(实时重新加载) 或 hot module replacement(热模块替换) 能力的 localhost server。而生产环境目标则转移至其他方面，关注点在于压缩 bundle、更轻量的 source map、资源优化等，通过这些优化方式改善加载时间。由于要遵循逻辑分离，通常每个环境编写彼此独立的 webpack 配。例如，生产环境webpack.prod.js和开发环境webpack.dev.js两个配置虽然有区别，但是也有相同的部分，我们可以把共用部分抽离成一个单独的文件webpck.base.js，为了将这些配置合并在一起，我们将使用一个名为 webpack-merge 的工具1npm install --S webpack-merge webpack.base.js123456789101112131415161718const path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/index.js' &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; title: 'Production' &#125;) ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; webpack.dev.js123456789const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; mode: 'development', devtool:'cheap-module-eval-source-map',//开发模式推荐 devServer: &#123; contentBase: './dist' &#125;&#125;); webpack.prod.js12345const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; mode: 'production',&#125;); 缩小解析范围noParse：不分析指定模块内的依赖。例如项目引用了jquery，而jquery本身不依赖其它文件，就可以指定noParseinclude：指定解析范围exclude： 是必不匹配选项，优先于 test 和 include1234567891011121314151617181920module.exports = &#123; module: &#123; noParse: /jquery|lodash/, rules: [ &#123; test: /\\.js$/, include: [ path.resolve(__dirname, \"src\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], //exclude: /node_modules/, //屏蔽不需要处理的文件夹 use: &#123; loader: \"babel-loader\" &#125; &#125; ] &#125;&#125;; happypack由于 JavaScript 是单线程模型，要想发挥多核 CPU 的能力，只能通过多进程去实现由于分配多进程也需要消耗资源，所以项目不大的情况下 使用happypack有可能使打包时间延长npm i -D happypack12345678910111213141516171819202122232425262728293031323334353637383940const HappyPack = require('happypack');const os = require('os');const happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, //把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行 loader: 'happypack/loader?id=happyBabel', //排除node_modules 目录下的文件 exclude: /node_modules/ &#125;, &#123; test: /\\.less$/, use: 'happypack/loader?id=styles' &#125;, ] &#125;,plugins: [ new HappyPack(&#123; //用id来标识 happypack处理那里类文件 id: 'happyBabel', //如何处理 用法和loader 的配置一样 loaders: [&#123; loader: 'babel-loader?cacheDirectory=true', &#125;], //共享进程池 threadPool: happyThreadPool, //允许 HappyPack 输出日志 verbose: true, &#125;), new HappyPack(&#123; id: 'styles', threads: 2, loaders: [ 'style-loader', 'css-loader', 'less-loader' ] &#125;) ]&#125; IgnorePlugin举个栗子，moment 2.18 会将所有本地化内容和核心功能一起打包。你可使用 IgnorePlugin 在打包时忽略本地化内容，然后手动引入你需要的包1234567891011121314//webpackconst webpack = require('webpack');module.exports = &#123; ... plugins: [ new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment/) ... ],&#125;;//jsimport 'moment/local/zh-cn' //手动引入中文包moment.local('zh-cn')//js其它逻辑 抽取公共代码12345678910111213141516171819202122232425module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendors: &#123; // 抽离第三方库为单独的文件 test: /node_modules/, // 指定是node_modules下的第三方包 //test: /react|react-dom/, // 指定react.也可以在entry里指定，如 vendor: [\"react\", \"react-dom\"] chunks: 'initial',//chunks指定从哪开始抽离 initial代表从入口处 提供all可能特别强大，因为这意味着即使在异步块和非异步块之间也可以共享块 name: 'vendors', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 1 &#125;, commons: &#123; // 抽离自己写的公共代码 // test: /[\\\\/]src[\\\\/]common[\\\\/]/, test: path.resolve(__dirname,'./src/common'), chunks: 'initial', name: 'commons', // 任意命名 minSize: 0, // 只要超出3000字节就抽离出来 minChunks: 2, //文件被引用两次就抽离 priority: -20 &#125; &#125; &#125; &#125;&#125;; dll动态链接库一个项目中的第三方包我们大多数情况下是不需要修改的，当项目中我们自己文件的更改导致整个项目重新打包是很消耗性能的，比如，第三方库我们完全不需要再重新打包。 DllPlugin就是为了解决这个问题，它会将我们的第三方库生成为动态链接库，这样当项目更新重新打包时候就不再需要打包第三方库的部分，只需要引用这个动态链接库即可。 DllPlugin插件： 用于打包出动态连接库通常单独写一个配置文件来打包动态链接库，新建webpack.dll.js12345678910111213141516module.exports = &#123; entry: &#123; react: [&apos;react&apos;,&apos;react-dom&apos;] //react模块打包到一个动态连接库 &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].dll.js&apos;, //\b输出动态连接库的文件名称 library: &apos;_dll_[name]&apos; //全局变量名称 &#125;, plugins: [ new webpack.DllPlugin(&#123; name: &apos;_dll_[name]&apos;, //和output.library中一致，值就是输出的manifest.json中的 name值 path: path.join(__dirname, &apos;dist&apos;, &apos;[name].manifest.json&apos;) &#125;) ]&#125; 1webpack --config webpack.dll.js --mode production 最终会在dist目录下生成两个文件react.dll.js和react.manifest.json。manifest.json这个文件是用来让 DLLReferencePlugin 映射到相关的依赖上去的。使用时，在index.html中手动引入react.dll.js1&lt;script src=\"./react.dll.js\"&gt;&lt;/script&gt; DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库正式的项目打包时配置DllReferencePlugin123456plugins: [ new webpack.DllReferencePlugin(&#123; //包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径 manifest: require(path.join(__dirname, 'dist', 'react.manifest.json')), &#125;)], 1webpack --config webpack.config.js --mode development 这样的话，如果我们项目中引用了某个库，打包时先在manifest.json清单里查找，如果有，就直接使用react.dll.js中的模块，无需再次咋报；如果没有的话，才会引入node_modules目录下的对应文件进行打包 splitchunks 和dllplugin可以并存吗DllPlugin服务的目标场景是develop环境，DllPlugin打包出的文件则稍显笨重。例如new webpack.IgnorePlugin(/^.\\/locale$/, /moment$/), 这种优化moment大小的方式如果moment在dll的entry中，那么在生成的dll文件夹下的包的大小也不会优化了。而在对加载效率更为苛刻的production环境,推荐使用splitChunks进行优化。 参考webpack 4 Code Splitting 的 splitChunks 配置探索webpack4中， splitchunks 和dllplugin可以并存吗？一步一步的了解webpack4的splitChunk插件","categories":[],"tags":[]},{"title":"webpack4.x常用配置","slug":"webpack4-x常用配置","date":"2019-03-08T14:31:19.000Z","updated":"2019-03-13T00:07:08.454Z","comments":true,"path":"2019/03/08/webpack4-x常用配置/","link":"","permalink":"http://jtao.pro/2019/03/08/webpack4-x常用配置/","excerpt":"","text":"之前把公司的系统管理平台项目的打包工具升级到了webpack4，做了一定程度的优化，得到如下效果： 文件打包后的大小：升级前 27.1M升级后 17.8M 打包时间升级前 425秒升级后 初次打包124秒, 后续打包 27秒 优化开发流程能脱离开发机，实现本地跨域调接口，同时保留开发机监控、实时线上预览功能 持久缓存代码块的hash值，只跟随修改的文件改变 接下来会用2-3篇文章对webpack4.x的基本应用做一下介绍。 创建一个项目123mkdir webpack-reactcd webpack-reactnpm init -y 安装webpack依赖1npm i webpack webpack-cli -D 注：在 webpack 3 中，webpack 和它的 CLI 都是在同一个包中，但在第4版中，他们已经将两者分开来更好地管理它们。所以安装时，最好是 webpack 和 webpack-cli 同时安装 在package.json中添加webpack命令 1234\"scripts\": &#123;····· \"start\": \"webpack --mode development\", \"build\": \"webpack --mode production\"&#125;, –mode 模式 (必选，不然会有 WARNING)，是 webpack4 新增的参数选项，默认是 production 常规配置(以打包react应用为例)安装 react 和 react-dom 作为生产依赖1npm i react react-dom -S 安装 babel安装 babel-loader，@babel/core，@babel/preset-env，@babel/preset-react 作为 dev 开发依赖1npm i babel-loader@8 @babel/core @babel/preset-env @babel/preset-react -D babel-loader：使用 Babel 转换 JavaScript依赖关系的 Webpack 加载器 @babel/core：即 babel-core，将 ES6 代码转换为 ES5 @babel/preset-env：即 babel-preset-env，根据您要支持的浏览器，决定使用哪些 transformations / plugins 和 polyfills，例如为旧浏览器提供现代浏览器的新特性 @babel/preset-react：即 babel-preset-react，针对所有 React 插件的 Babel 预设，例如将 JSX 转换为函数注：babel 7 使用了 @babel 命名空间来区分官方包，因此以前的官方包 babel-xxx 改成了 @babel/xxx webpack配置文件简单介绍一下配置文件中常见的几大块内容123456789module.exports = &#123; entry: &#123;&#125;, // 打包入口：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 output: &#123;&#125;, // 输出 resolve: &#123;&#125;, // 配置解析：配置别名、extensions 自动解析确定的扩展等等 devServer: &#123;&#125;, // 开发服务器：run dev/start 的配置，如端口、proxy等 module: &#123;&#125;, // 模块配置：配置loader（处理非 JavaScript 文件，比如 less、sass、jsx、图片等等）等 plugins: [], // 插件的配置：打包优化、资源管理和注入环境变量 optimization:&#123;&#125;//打包优化&#125; entry的三种形式： 字符串：单入口单出口 1entry:'./src/index.js' 数组：多入口单出口 1entry: ['./src/foo.js','./src/bar.js'] 对象：多入口多出口 1234entry:&#123; foo:'./src/foo.js', bar:'./src/bar.js'&#125; 在webpack.config.js中写入：1234567891011121314151617181920module.exports = &#123; entry:'./src/index.js', output: &#123; filename: '[name].js',//使用[name]关键字来动态生成输出文件的名字 //动态生成的文件名和我们在entry对象中设置的名字一样，如果entry不是个对象，那么此时输出的文件名会默认为main path:path.resolve(__dirname,'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, //屏蔽不需要处理的文件夹 use: &#123; loader: \"babel-loader\" &#125; &#125; ] &#125;&#125;; 创建.babelrc文件并配置npm install –save-dev @babel/plugin-transform-runtimenpm install –save @babel/runtime以上两个插件通常都是一起装上， @babel/runtime用于打包到生产环境transform-runtime可以重用Babel注入的帮助代码来减小codesizetransform-runtime 使用内置的一些东西例如Promise,Set,Symbol等，所以实例上不存在，如’aaa’.includes(‘a’)不可用babel-polyfill则是通过改写全局prototype的方式实现，但体积大，避免全量引用更多可阅读babel-polyfill与babel-plugin-transform-runtime、 了解 Babel 6 &amp; 7 生态123456789101112&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;:[ [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],//处理装饰器 需安装插件 [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot; : true &#125;],//处理类的属性 &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-syntax-dynamic-import&quot; //处理懒加载 见下方 ]&#125; 动态加载安装插件：npm i @babel/plugin-syntax-dynamic-import -D然后记得像上边那样配置babel的插件这个插件主要是用来支持es6草案语法：import()。vue、react动态路由就是基于此接下来就能愉快的这样写了：123import('./a.js').then(data=&gt;&#123; console.log('动态加载a文件，内容是：', data);&#125;) 安装 html-webpack-plugin 开发依赖。这个插件可以把打包后的静态资源自动添加到模板文件中1npm i html-webpack-plugin -D 修改webpack.config.js123456789101112plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './src/index.html', // 配置要被编译的html文件 hash: true, //静态资源是否hash // 压缩 =&gt; production 模式使用 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ], 安装开发服务webpack-dev-server可以提供自动刷新、模拟数据以及跨域问题1npm i webpack-dev-server -D 12345//package.json\"scripts\": &#123; \"start\": \"webpack-dev-server --open --mode development\", ...&#125; 实现 react热更新：安装loader1npm install react-hot-loader -S 修改webpack.config.js123456789101112const webpack = require('webpack');module.exports = &#123; ... plugins: [ new webpack.HotModuleReplacementPlugin() ... ], devServer: &#123; hot: true &#125;&#125;; 需要在入口文件 src/index.js文件末尾写入：1module.hot.accept(); 跨域访问：1234567891011121314151617181920212223242526272829devServer: &#123; host: '0.0.0.0', // 可通过127.0.0.1 localhost 或者 局域网本机ip访问 port: '8888', //指定端口 historyApiFallback: &#123; index: '/index.html', // 任意的 404 响应都可能需要被替代为 index.html &#125;, hot: true, open: true,//启动服务时自动打开浏览器 overlay: &#123;//错误提示浮层 error: true, &#125;, /*proxy: &#123;//代理 '/api': 'http://localhost:3333', &#125;,^/ // 重写路径 如：访问http://localhost:8888/api/user相当于访问http://localhost:3333/user proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\", pathRewrite: &#123;\"^/api\" : \"\"&#125;, changeOrigin: true, //跨域设置true &#125; &#125;, //前端模拟数据 /*before(app)&#123; app.get('/userInfo',(req,res)=&gt;&#123; res.json(&#123;name:'Bob'&#125;) &#125;) &#125;*/ &#125; 处理css1npm install style-loader css-loader -D 还可以根据需要安装less、 sass1npm i less less-loader node-sass sass-loader -D 简单来说，style-loader是将css-loader打包好的css代码以&lt;style&gt; 标签的形式插入到html文件中12345&#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], //动指定必须处理的文件夹 use: ['style-loader', 'css-loader']&#125; 如果需要单独把 CSS 文件分离出来，我们需要使用 mini-css-extract-plugin 插件抽取 css 到独立文件。optimize-css-assets-webpack-plugin插件用于压缩css1npm i mini-css-extract-plugin optimize-css-assets-webpack-plugin -D 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ MiniCssExtractPlugin.loader, 'css-loader', ] &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, &#123;loader: 'css-loader'&#125;, &#123;loader: 'less-loader'&#125;, 'postcss-loader', ] &#125;, ] &#125;, plugins: [ //... new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:7].css', // filename: 'css/[name].css', // 输出到css文件夹下面 chunkFilename: '[id].[chunkhash:7].css', &#125;) ], optimization :&#123; minimizer:[ new OptimizeCSSAssetsPlugin(&#123;//压缩css cssProcessorOptions: &#123; safe: true &#125; &#125;), new UglifyJsPlugin(&#123; //压缩js cache: true, parallel: true,//并发打包 同事压缩多个 sourceMap: false, // set to true if you want JS source maps uglifyOptions: &#123; compress: true, &#125; &#125;), ], &#125;&#125; 写 css 时不免要考虑到浏览器兼容问题，如 transform 属性，需要添加浏览器前缀以适配其他浏览器，使用到 postcss-loader 这个 loader，autoprefixer 是它的插件1npm i postcss-loader autoprefixer -D 123456789101112131415161718192021222324module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ MiniCssExtractPlugin.loader, 'css-loader', //方式一，写成字符串'postcss-loader'，当前目录额外新建一个postcss.config.js文件： 'postcss-loader', //方式二,直接配置一个对象： /*&#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] &#125; &#125;*/ ] &#125; ] &#125;,&#125; postcss.config.js文件1234567module.exports = &#123; plugins: [ require('autoprefixer')(&#123; 'browsers': ['&gt; 1%', 'last 2 versions'] &#125;) ]&#125;; 处理图片和字体下面这两个loader通常都配合使用123456789101112131415npm i url-loader file-loader -D...// 当文件小于9k，则转成base64 超过9k，则会默认使用file-loader把文件产出&#123; test: /\\.(png|jpg|jpeg|gif|svg)/, use: &#123; loader: 'url-loader', options: &#123; // name: assetsPath('images/[name].[hash:7].[ext]'), // 图片输出的路径 name: 'images/[name].[hash:7].[ext]', // 图片输出的路径 limit: 9*1024, publicPath:'public' // 也给图片路径单独配置publicPath &#125; &#125;&#125;, html-withimg-loader：html中直接使用img标签src加载图片的话，因为没有被依赖，图片将不会被打包。这个loader解决这个问题，图片会被打包，而且路径也处理妥当。123456loaders: [ &#123; test: /\\.(htm|html)$/i, loader: 'html-withimg-loader' &#125;] 暴露全局变量法一：1npm install expose-loader --save-dev 法二：123456789// webpack.config.jslet webpack = require('webpack')...plugins:[ new webpack.ProvidePlugin(&#123; '$':'jquery' &#125;)],// externals:['jquery'] //法三：引入（CDN ），不打包（externals配置项） 定义环境变量，定义环境变量后，可以在自己的业务代码中使用变量12345678910let webpack = require('webpack')...plugins:[ new webpack.DefinePlugin(&#123; DEV:\"'dev'\", // 不推荐 //=&gt;'dev' PRO:JSON.stringify('production'), //推荐 //=&gt;'production' FLAG:'false', //=&gt;false EXPRESSION:'2+1', //=&gt;3 &#125;)], resolve1234567resolve: &#123; extensions: [\".js\", \".less\", \".json\"], //代码中引入文件时可以省略后缀名 alias: &#123; // 配置别名 方便后续直接引用别名，无须写很长的地址 '@': path.resolve(__dirname, '../src'), 'jquery': 'jquery/jquery.min.js', &#125;&#125;, clean-webpack-plugin 插件它可以在打包前清理指定的目录1npm install clean-webpack-plugin -D 修改 webpack.config.js 文件1234const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125; 打包进度1npm i -D progress-bar-webpack-plugin 1234567var ProgressBarPlugin = require('progress-bar-webpack-plugin');... plugins: [ new ProgressBarPlugin()] 错误提示: npm i -D friendly-errors-webpack-plugin看到这里大家已经看到规律了，所有的webpack插件用法，都是先引入，然后在plugins: []里面new一个实例","categories":[{"name":"webpack","slug":"webpack","permalink":"http://jtao.pro/categories/webpack/"}],"tags":[{"name":"webpack4.x 项目构建","slug":"webpack4-x-项目构建","permalink":"http://jtao.pro/tags/webpack4-x-项目构建/"}]},{"title":"Js中常用的设计模式","slug":"js中常用的设计模式","date":"2018-01-29T02:12:33.000Z","updated":"2018-01-29T07:11:37.954Z","comments":true,"path":"2018/01/29/js中常用的设计模式/","link":"","permalink":"http://jtao.pro/2018/01/29/js中常用的设计模式/","excerpt":"","text":"模式的起源模式并非起源于软件工程行业，而是建筑学领域。模式的研究起源于建筑设计大师Christopher Alexander关于城市规划和建筑设计的著作。但尽管著作针对建筑学领域，但实际上适用于所有的工程设计领域，包括软件开发设计领域。 亚历山大在《建筑的永恒之道》里这样描述：模式是一条由三个部分组成的通用规则：它表示了一个特定环境、一类问题和一个解决方案之间的关系。每一个模式描述了一个不断重复发生的问题，以及该问题解决方案的核心设计。 在他的另一本书《建筑模式语言》中提到了现在已经定义了253种模式。比如：说明城市主要的结构：亚文化区的镶嵌、分散的工作点、城市的魅力、地方交通区住宅团组：户型混合、公共性的程度、住宅团组、联排式住宅、丘状住宅、老人天地室内环境和室外环境、阴和阳总是一气呵成针对住宅：夫妻的领域、儿童的领域、朝东的卧室、农家的厨房、私家的沿街露台、个人居室、起居空间的序列、多床卧室、浴室、大储藏室 1987年，Ward Cunninghan和Kent Beck在一起用Smalltalk做设计用户界面的工作。他们决定使用Alexander的理论发展一个有五个模式的语言来指导Smalltalk的新手，因此，《Using Pattern Languages for Object-Oriented Programs》论文发表。Ward Cunninghan和Kent Beck是对设计模式的发展影响最大的先行者。 第一个也是可以说是在软件工程设计模式中出版的最具代表性的最具代表性的正式作品之一，是1994年的一本书《Design Patterns》，称为设计模式。这是由Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides撰写的，该团体被称为“四人组”（或简称GoF）。有兴趣的话大家可以看一下这篇文章 模式的简史和形而上学 设计模式的作用 [ 开发 ]开发效率高利于团队协作 [ 维护 ]有利于代码的升级改版逻辑清晰，代码严谨，利于后期的维护 [ 通用 ]我们依托设计模式可以实现组件化、模块化、插件化、框架化以及一些常用类库方法的编写 JS中常用的设计模式 单例设计模式、构造-原型设计模式、发布订阅设计模式… 单例设计模式123456789101112131415//单例模式：把实现当前这个模块所有的属性和方法汇总到同一个命名空间下（分组作用，避免了全局变量的污染）var app=(function()&#123; //实现当前模块具体业务逻辑的方法全部存放在闭包中 var fn=function()&#123; //... &#125; return &#123; init:function()&#123; //入口方法：控制当前模块具体的业务逻辑顺序 fn(); &#125; &#125;&#125;)();app.init(); 单体模式的优点是： 可以用来划分命名空间，减少全局变量的数量。 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。 可以被实例化，且实例化一次。 构造原型模式：最贴近OOP面向对象编程思想的 封装类库、插件或者UI组件，基本上都是基于构造原型模式来开发的1234567891011121314151617181920212223242526class Tool&#123; constructor()&#123; this.isCompatible='addEventListener' in document;//=&gt;如果不兼容返回FALSE(IE6~8) &#125; //=&gt;挂载到原型上的方法 css()&#123; //... &#125; //=&gt;挂载到普通对象上的方法 static distinct()&#123; //... &#125;&#125;class Banner extends Tool&#123; constructor(...arg)&#123; super(); this.xxx=xxx; &#125; //挂载到子类原型上的方法 bindData()&#123; this.css();//=&gt;把父类原型上的方法执行（子类继承了父类，那么子类的实例就可以调取父类原型上的方法了） this.distinct===undefined;//子类的实例只能调取父类原型上的方法和父类给实例提供的私有属性方法，但是父类做为普通对象加入的静态方法，子类的实例是无法调取的 (只有这样才可以调取使用：Tool.distinct()) &#125;&#125; 我有三个类 A/B/C ，我想让C继承A和B123456789class A&#123; ...&#125;class B extends A&#123; ...&#125;class C extends B&#123; ...&#125; 发布订阅设计模式 俗称叫做“观察者模式”不同于单例和构造，发布订阅是小型设计模式，应用到某一个具体的需求中：凡是当到达某个条件之后要执行N多方法，我们都可以依托于发布订阅设计模式管理和规划我们的JS代码 实现思路和原理：1、我们先创建一个计划表（容器）2、后期需要做什么事情，我们都依次把需要处理的事情增加到计划表中3、当符合某个条件的时候，我们只需要通知计划表中的方法按照顺序依次执行即可 JQ中的发布订阅 JQ中提供了实现发布订阅设计模式的方法123456789101112131415161718192021222324$(function () &#123; // 将被添加到列表的一个简单的函数 var foo = function( value ) &#123; alert( \"foo:\" + value ); &#125;; var callbacks = $.Callbacks(); // 添加函数 \"foo\" 到列表 callbacks.add( foo ); // 传入参数调用所有回调列表 callbacks.fire( \"hello\" ); // 输出: \"foo: hello\" callbacks.fire( \"world\" ); // 输出: \"foo: world\" // 添加另一个函数到列表 var bar = function( value ,x)&#123; alert( \"bar:\" + value +x); &#125;; // 添加这个函数到列表 callbacks.add( bar ); // callbacks.remove(fn);//=&gt;移除方法 // 传入参数调用所有回调列表(按照顺序执行),\"hello again\",666 会分别作为实参传递给每一个需要执行的方法 callbacks.fire( \"hello again\",666 ); // 输出: // \"foo: hello again\" // \"bar: hello again666\"&#125;) 实现一个发布订阅1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var Event = (function() &#123; var clientList = &#123;&#125;; var add, fire, remove; add = function(key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; fire = function() &#123; var key = [].shift.call(arguments); var fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function(key, fn) &#123; var fns = clientList[key]; // key对应的消息么有被人订阅 if (!fns) &#123; return false; &#125; // 没有传入fn(具体的回调函数), 表示取消key对应的所有订阅 if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; // 反向遍历 for (var i = fns.length - 1; i &gt;= 0; i--) &#123; var _fn = fns[i]; if (_fn === fn) &#123; // 删除订阅回调函数 fns.splice(i, 1); &#125; &#125; &#125; &#125;; return &#123; add: add, fire: fire, remove: remove &#125;&#125;()); var fn1 = function(a) &#123; console.log(a);&#125;; var fn2 = function(a)&#123; console.log(a+'fn2');&#125;;var fn3 = function(a)&#123; console.log(a+'fn3');&#125;;Event.add(\"commit\", fn1) //订阅触发某状态时需要执行的函数Event.add(\"commit\", fn2)Event.remove(\"commit\", fn2)//删除Event.add(\"commit\", fn3)Event.fire(\"commit\",10); //触发执行","categories":[{"name":"js","slug":"js","permalink":"http://jtao.pro/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://jtao.pro/tags/设计模式/"}]},{"title":"Redux基本用发","slug":"redux基本用发","date":"2018-01-21T08:51:49.000Z","updated":"2018-01-29T06:57:43.185Z","comments":true,"path":"2018/01/21/redux基本用发/","link":"","permalink":"http://jtao.pro/2018/01/21/redux基本用发/","excerpt":"","text":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 是怎么做到可预测的呢？ 单一数据源，单一状态树，state State 是只读的。所有数据都是只读的，要想修改数据，必须 dispatch 一个 action 来描述什么发生了改变。这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图 使用纯函数来执行修改。纯函数的返回值只由它调用时的参数决定，它的执行不依赖于系统的状态（比如：何时、何处调用它）。Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state工作流程 需要改变状态时，现派发一个动作 1store.dispatch(action); Reducer匹配action类型，返回新的state 123456789function reducer(state=&#123;xx:xx&#125;,action) &#123; switch (action.type)&#123; case 'xxx': return &#123;新的state&#125;; case 'xxx': return &#123;新的state&#125;; &#125; return state;&#125; State 一旦有变化，Store 就会调用监听函数。 123//通常在componentDidMount函数里设置监听函数//订阅 每次dispatch后更新状态store.subscribe(() =&gt; &#123;this.setState(&#123;n:store.getState().number&#125;) 直接看一个简单的例子 index.js 1234import React from 'react'import ReactDOM from 'react-dom';import Counter from './Counter'ReactDOM.render(&lt;Counter/&gt;, window.root) store.js 123456789101112import &#123;createStore&#125; from 'redux';function reducer(state = &#123;number: 0&#125;, action) &#123; //可以给state设置初始值 switch (action.type) &#123; case 'ADD': //ADD、MINUS是提前定义好的各种action return &#123;number: state.number + action.count&#125;; //匹配action中的type，返回新的state case 'MINUS': return &#123;number: state.number - action.count&#125;; default: return state; &#125;&#125;export default createStore(reducer); //创建一个状态树 Counter.js 1234567891011121314151617181920212223242526272829import React from 'react';import store from './store.js';// 组件更新 属性的更新 更新状态 ,将redux中的数据转化成自己的状态export default class Counter extends React.Component &#123; constructor()&#123; super(); console.log(store.getState()); this.state = &#123;n:store.getState().number&#125; //store.getState() 拿到store里的state &#125; componentDidMount()&#123; this.un = store.subscribe(() =&gt; &#123; //订阅 每次dispatch后更新状态 this.setState(&#123;n:store.getState().number&#125;) &#125;) &#125; componentWillUnmount()&#123; //组件销毁时 需要将其监听的函数移除掉 this.un(); &#125; render()&#123; return &lt;div&gt; &lt;button onClick=&#123;()=&gt;&#123; //每次dispatch后都需要重新更新状态=&gt;subscribe store.dispatch(&#123;type:'ADD',count:1&#125;) //提交带有type属性的action &#125;&#125;&gt;+&lt;/button&gt; &lt;span&gt;&#123;this.state.n&#125;&lt;/span&gt; &lt;button onClick=&#123;()=&gt;&#123; store.dispatch(&#123;type:'MINUS',count:1&#125;) &#125;&#125;&gt;-&lt;/button&gt; &lt;/div&gt; &#125;&#125;","categories":[{"name":"redux","slug":"redux","permalink":"http://jtao.pro/categories/redux/"}],"tags":[{"name":"react redux","slug":"react-redux","permalink":"http://jtao.pro/tags/react-redux/"}]},{"title":"Express的基础语法","slug":"Express的基础语法","date":"2018-01-08T04:12:16.000Z","updated":"2018-01-21T14:58:52.643Z","comments":true,"path":"2018/01/08/Express的基础语法/","link":"","permalink":"http://jtao.pro/2018/01/08/Express的基础语法/","excerpt":"","text":"express是node的一个框架，我们可以基于express快速搭建一个web服务，并且提供一些供客户端调用的api接口（支持中间件、支持路由处理等）；还有一个框架和它类似，叫做koa. 学习Express：http://www.expressjs.com.cn/4x/api.html 安装Express如果当前电脑已经安装了yarn，我们可以基于yarn安装express及相关配套插件12345678yarn init -y 生成package.json文件/* * express：express核心框架 * body-parser：用来快速解析请求主体中内容的 * express-session / cookie-parser：方便我们在express中操作session的 */yarn add express body-parser express-session cookie-parser 创建服务，监听端口基于NODE内置模块，使用原生JS代码实现WEB服务123456789101112131415let http = require('http'), fs = require('fs'), url = require('url');http.createServer((req, res)=&gt; &#123; let &#123;url:reqURL, method, headers&#125;=req, &#123;pathname, query&#125;=url.parse(reqURL, true); if (pathname === '/getMatchList' &amp;&amp; method=='GET') &#123; &#125; if(pathname==='/reg' &amp;&amp; method=='POST')&#123; &#125;&#125;).listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;); 基于express框架完成 express就是把我们自己用原生写的封装好了，我们以后直接调取使用即可（方便开发，有点类似于JQ）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);app.get(`/getMatchList`, (req, res)=&gt; &#123; //=&gt;等价于原生 //req.url 请求的地址+问号传参 //req.method 请求的方式(大写) //req.headers 请求头(小写) //=&gt;EXPRESS新提供的 //req.path 相当于我们原生中通过URL内置模块的PARSE方法解析出来的PATH-NAME //req.query 相当于解析出来的QUERY //=&gt;等价于原生 //res.writeHead 重写响应头 //res.write 响应主体 //res.end 结束响应(响应主体) /* res.writeHead(200, &#123; 'content-type': 'application/json' &#125;); res.end(JSON.stringify(&#123;\"id\": 1, \"name\": \"zf \"&#125;));//=&gt;只能返回字符串或者Buffer格式数据 //--------- fs.readFile('./index.html',(err,data)=&gt;&#123; if(err) return; res.writeHead(200,&#123; 'content-type':'text/html' &#125;); res.end(data); &#125;); //=&gt;好麻烦 */ //=&gt;EXPRESS独有的 //res.sendFile('./index.html',&#123;root:__dirname&#125;); 读取指定的文件，并且把内容响应给客户端 //res.json(&#123;\"id\":1,\"name\":\"zf\"&#125;); 我们可以直接放JSON,EXPRESS帮我们把它转换为字符串返回给客户端（并且设置好了响应头信息） //res.send() 综合体 //res.statusCode = 200; 设置状态码 //res.redirect() 重定向(对应状态码中的302/301) //res.sendStatus(404); 返回状态码并且附带一些状态码的描述信息 //...&#125;);app.post(`/reg`, (req, res)=&gt; &#123;&#125;); Express中间件 使用中间件的两大作用：1、想要提取部分公共代码2、想要在主体API逻辑处理前，做一些特殊处理（把传递的参数做特殊的处理）…123456789101112131415161718192021222324252627let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;所有的客户端请求都会先执行这个中间件(然后执行NEXT后在进入下一个处理程序)app.use((req, res, next)=&gt; &#123; //next:执行下一个处理(当前这个中间件根据情况，如果需要走到下一个操作，必须执行NEXT，如果不需要，直接响应内容即可) if (req.query.name) &#123; req.userName = req.query.name;//=&gt;把获取的内容写在了userName自定义属性上 next(); &#125; else &#123; res.send(`name必须传递`); &#125;&#125;);//=&gt;只有请求的地址中包含`/user`的才会进入这个中间件app.use(`/user`, (req, res, next)=&gt; &#123; req.userName += '@'; next();&#125;);app.get(`/user`, (req, res)=&gt; &#123; res.send(`My name is $&#123;req.userName&#125;`);&#125;);app.get(`/article`, (req, res)=&gt; &#123; res.send(`Article author is $&#123;req.userName&#125;`);&#125;); Express中的路由router 在真实项目中，我们为了有效的管理接口，我们会把相同功能体系的接口进行归类；在实现的时候，也会分类实现（分组管理）； 例如：/user/signin/user/signup /product/query/product/search /log/info GET获取 POST请求设置 同一个地址，因为请求方式不一样，实现不一样的功能… 此类操作，我们可以基于Express中的路由来完成 1、我们创建一个routers文件夹，在这个文件夹中存储所有功能模块的接口信息（分类存储） 2、在每一个路由模块中完成API接口的编写（举例：user模块）12345678910111213let express = require('express'), router = express.Router();//=&gt;router和app其实差不多router.use((req, res, next)=&gt; &#123; console.log(`ok`); next();&#125;);router.post(`/signin`, (req, res)=&gt; &#123; res.send('login success');&#125;);router.post(`/signup`, (req, res)=&gt; &#123; res.send('register success');&#125;);module.exports = router;//=&gt;把创建的路由导出,方便后续调取使用 3、在server中需要调取使用1234let express = require('express'), app = express();...app.use(`/user`, require('./routers/user')); Express中获取客户端传递的信息 客户端把信息传递给服务器：1、问号传参（GET请求）2、设置请求主体（POST请求）3、设置请求头（cookie等信息传送）… 问号传参 &amp; 请求头12345app.get(`/query`, (req, res)=&gt; &#123; console.log(req.headers);//=&gt;通过REQ的HEADERS可以直接的获取请求头信息(想获取其中的某一个:REQ.HEADERS.HOST...) res.send(req.query);//=&gt;通过REQ中的QUERY就可以获取问号传递的参数值(并且存储的方式是KEY:VALUE)&#125;); 请求主体123456789101112131415161718192021//=&gt;基于传统的内置模块自己实现app.use(`/reg`, (req, res, next)=&gt; &#123; //=&gt;POST请求获取请求主体内容,需要基于事件完成 let str = ``; req.on('data', chunk=&gt; &#123; //=&gt;正在接收请求主体中的内容(一般内容偏多) str += chunk; &#125;); req.on('end', ()=&gt; &#123; //=&gt;接收结束,此时STR存储的就是传递进来的信息 //=&gt;客户端传递给服务器的信息一般都是字符串格式的(JSON字符串或者普通的FORMAT-DATA字符串[xxx=xxx&amp;xxx=xxx]) //=&gt;真实项目中我们还要把字符串转化为对象方式(方便操作) let data = require('querystring').parse(str);//=&gt;这个内置模块就是把FORMAT-DATA变为对象键值对的方式存储 req.body = data;//=&gt;把解析后的数据放到REQ的自定义属性上,在其它的方法中可以获取使用 next(); &#125;);&#125;);app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;); 这种方式太麻烦了，我们可以使用第三方插件搞定刚才处理的事情：body-parser12345678let bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(bodyParser.json());app.use(bodyParser.raw());app.use(bodyParser.text());app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;); Express中静态文件的处理 基于express.static方法即可完成12345678910111213141516171819202122232425let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;真实项目中,我们一般都静态资源文件(HTML/CSS/JS/IMG...)存放在DIST或者LIB或者PUBLIC或者BUILD等指定的文件夹中app.use(express.static('dist'));//=&gt;大体实现原理let fs = require('fs'), path = require('path');let expressStatic = p=&gt; (req, res, next)=&gt; &#123; let pathname = path.join(`$&#123;__dirname&#125;/$&#123;p&#125;`, req.path); fs.readFile(pathname, (err, data)=&gt; &#123; if (err) &#123; //=&gt;找不到指定的文件 next(); &#125; else &#123; //=&gt;找到文件 res.sendFile(pathname); &#125; &#125;);&#125;;app.use(expressStatic('dist'));","categories":[{"name":"Express","slug":"Express","permalink":"http://jtao.pro/categories/Express/"}],"tags":[{"name":"Express NODE","slug":"Express-NODE","permalink":"http://jtao.pro/tags/Express-NODE/"}]}]}