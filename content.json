{"meta":{"title":"张峻滔的空间","subtitle":null,"description":null,"author":"Zhang Juntao","url":"http://zhangjuntao.com.cn"},"pages":[{"title":"category","date":"2018-01-21T13:31:15.493Z","updated":"2017-05-17T09:14:46.866Z","comments":false,"path":"category/index.html","permalink":"http://zhangjuntao.com.cn/category/index.html","excerpt":"","text":""},{"title":"about","date":"2018-01-21T13:31:15.508Z","updated":"2017-05-17T14:48:07.779Z","comments":false,"path":"about/index.html","permalink":"http://zhangjuntao.com.cn/about/index.html","excerpt":"","text":"about: type: meicon: icon-usertext_value: “中国矿业大学（北京）” “1992 重庆” “HTML / CSS / JavaScript / jQuery / zepto/ less / sass / gulp / webpack / Vue.js” type: Githubicon: icon-githubtext_key: Githubtext_value: “@Jtrust”text_value_url: https://github.com/Jtrust type: mailicon: icon-mailtext_key: E-mailtext_value: “jtarch@163.com” type: locationicon: icon-locationtext_value: 成都"},{"title":"project","date":"2018-01-21T13:31:15.481Z","updated":"2017-05-18T08:40:18.651Z","comments":false,"path":"project/index.html","permalink":"http://zhangjuntao.com.cn/project/index.html","excerpt":"","text":""},{"title":"tag","date":"2018-01-21T13:31:15.466Z","updated":"2017-05-17T09:15:56.490Z","comments":false,"path":"tag/index.html","permalink":"http://zhangjuntao.com.cn/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Redux基本用发","slug":"redux基本用发","date":"2018-01-21T08:51:49.000Z","updated":"2018-01-21T14:58:52.672Z","comments":true,"path":"2018/01/21/redux基本用发/","link":"","permalink":"http://zhangjuntao.com.cn/2018/01/21/redux基本用发/","excerpt":"","text":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 是怎么做到可预测的呢？ 单一数据源，单一状态树，state State 是只读的。所有数据都是只读的，要想修改数据，必须 dispatch 一个 action 来描述什么发生了改变。这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图 使用纯函数来执行修改。纯函数的返回值只由它调用时的参数决定，它的执行不依赖于系统的状态（比如：何时、何处调用它）。Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state工作流程 需要改变状态时，现派发一个动作 1store.dispatch(action); Reducer匹配action类型，返回新的state 123456789function reducer(state=&#123;xx:xx&#125;,action) &#123; switch (action.type)&#123; case &apos;xxx&apos;: return &#123;新的state&#125;; case &apos;xxx&apos;: return &#123;新的state&#125;; &#125; return state;&#125; State 一旦有变化，Store 就会调用监听函数。 123//通常在componentDidMount函数里设置监听函数//订阅 每次dispatch后更新状态store.subscribe(() =&gt; &#123;this.setState(&#123;n:store.getState().number&#125;) 直接看一个简单的例子 index.js1234import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;;import Counter from &apos;./Counter&apos;ReactDOM.render(&lt;Counter/&gt;, window.root) store.js123456789101112import &#123;createStore&#125; from &apos;redux&apos;;function reducer(state = &#123;number: 0&#125;, action) &#123; //可以给state设置初始值 switch (action.type) &#123; case &apos;ADD&apos;: //ADD、MINUS是提前定义好的各种action return &#123;number: state.number + action.count&#125;; //匹配action中的type，返回新的state case &apos;MINUS&apos;: return &#123;number: state.number - action.count&#125;; default: return state; &#125;&#125;export default createStore(reducer); //创建一个状态树 Counter.js1234567891011121314151617181920212223242526272829import React from &apos;react&apos;;import store from &apos;./store.js&apos;;// 组件更新 属性的更新 更新状态 ,将redux中的数据转化成自己的状态export default class Counter extends React.Component &#123; constructor()&#123; super(); console.log(store.getState()); this.state = &#123;n:store.getState().number&#125; //store.getState() 拿到store里的state &#125; componentDidMount()&#123; this.un = store.subscribe(() =&gt; &#123; //订阅 每次dispatch后更新状态 this.setState(&#123;n:store.getState().number&#125;) &#125;) &#125; componentWillUnmount()&#123; //组件销毁时 需要将其监听的函数移除掉 this.un(); &#125; render()&#123; return &lt;div&gt; &lt;button onClick=&#123;()=&gt;&#123; //每次dispatch后都需要重新更新状态=&gt;subscribe store.dispatch(&#123;type:&apos;ADD&apos;,count:1&#125;) //提交带有type属性的action &#125;&#125;&gt;+&lt;/button&gt; &lt;span&gt;&#123;this.state.n&#125;&lt;/span&gt; &lt;button onClick=&#123;()=&gt;&#123; store.dispatch(&#123;type:&apos;MINUS&apos;,count:1&#125;) &#125;&#125;&gt;-&lt;/button&gt; &lt;/div&gt; &#125;&#125;","categories":[{"name":"redux","slug":"redux","permalink":"http://zhangjuntao.com.cn/categories/redux/"}],"tags":[{"name":"react redux","slug":"react-redux","permalink":"http://zhangjuntao.com.cn/tags/react-redux/"}]},{"title":"Express的基础语法","slug":"Express的基础语法","date":"2018-01-08T04:12:16.000Z","updated":"2018-01-21T14:58:52.643Z","comments":true,"path":"2018/01/08/Express的基础语法/","link":"","permalink":"http://zhangjuntao.com.cn/2018/01/08/Express的基础语法/","excerpt":"","text":"express是node的一个框架，我们可以基于express快速搭建一个web服务，并且提供一些供客户端调用的api接口（支持中间件、支持路由处理等）；还有一个框架和它类似，叫做koa. 学习Express：http://www.expressjs.com.cn/4x/api.html 安装Express如果当前电脑已经安装了yarn，我们可以基于yarn安装express及相关配套插件12345678yarn init -y 生成package.json文件/* * express：express核心框架 * body-parser：用来快速解析请求主体中内容的 * express-session / cookie-parser：方便我们在express中操作session的 */yarn add express body-parser express-session cookie-parser 创建服务，监听端口基于NODE内置模块，使用原生JS代码实现WEB服务123456789101112131415let http = require('http'), fs = require('fs'), url = require('url');http.createServer((req, res)=&gt; &#123; let &#123;url:reqURL, method, headers&#125;=req, &#123;pathname, query&#125;=url.parse(reqURL, true); if (pathname === '/getMatchList' &amp;&amp; method=='GET') &#123; &#125; if(pathname==='/reg' &amp;&amp; method=='POST')&#123; &#125;&#125;).listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;); 基于express框架完成 express就是把我们自己用原生写的封装好了，我们以后直接调取使用即可（方便开发，有点类似于JQ）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);app.get(`/getMatchList`, (req, res)=&gt; &#123; //=&gt;等价于原生 //req.url 请求的地址+问号传参 //req.method 请求的方式(大写) //req.headers 请求头(小写) //=&gt;EXPRESS新提供的 //req.path 相当于我们原生中通过URL内置模块的PARSE方法解析出来的PATH-NAME //req.query 相当于解析出来的QUERY //=&gt;等价于原生 //res.writeHead 重写响应头 //res.write 响应主体 //res.end 结束响应(响应主体) /* res.writeHead(200, &#123; 'content-type': 'application/json' &#125;); res.end(JSON.stringify(&#123;\"id\": 1, \"name\": \"zf \"&#125;));//=&gt;只能返回字符串或者Buffer格式数据 //--------- fs.readFile('./index.html',(err,data)=&gt;&#123; if(err) return; res.writeHead(200,&#123; 'content-type':'text/html' &#125;); res.end(data); &#125;); //=&gt;好麻烦 */ //=&gt;EXPRESS独有的 //res.sendFile('./index.html',&#123;root:__dirname&#125;); 读取指定的文件，并且把内容响应给客户端 //res.json(&#123;\"id\":1,\"name\":\"zf\"&#125;); 我们可以直接放JSON,EXPRESS帮我们把它转换为字符串返回给客户端（并且设置好了响应头信息） //res.send() 综合体 //res.statusCode = 200; 设置状态码 //res.redirect() 重定向(对应状态码中的302/301) //res.sendStatus(404); 返回状态码并且附带一些状态码的描述信息 //...&#125;);app.post(`/reg`, (req, res)=&gt; &#123;&#125;); Express中间件 使用中间件的两大作用：1、想要提取部分公共代码2、想要在主体API逻辑处理前，做一些特殊处理（把传递的参数做特殊的处理）…123456789101112131415161718192021222324252627let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;所有的客户端请求都会先执行这个中间件(然后执行NEXT后在进入下一个处理程序)app.use((req, res, next)=&gt; &#123; //next:执行下一个处理(当前这个中间件根据情况，如果需要走到下一个操作，必须执行NEXT，如果不需要，直接响应内容即可) if (req.query.name) &#123; req.userName = req.query.name;//=&gt;把获取的内容写在了userName自定义属性上 next(); &#125; else &#123; res.send(`name必须传递`); &#125;&#125;);//=&gt;只有请求的地址中包含`/user`的才会进入这个中间件app.use(`/user`, (req, res, next)=&gt; &#123; req.userName += '@'; next();&#125;);app.get(`/user`, (req, res)=&gt; &#123; res.send(`My name is $&#123;req.userName&#125;`);&#125;);app.get(`/article`, (req, res)=&gt; &#123; res.send(`Article author is $&#123;req.userName&#125;`);&#125;); Express中的路由router 在真实项目中，我们为了有效的管理接口，我们会把相同功能体系的接口进行归类；在实现的时候，也会分类实现（分组管理）； 例如：/user/signin/user/signup /product/query/product/search /log/info GET获取 POST请求设置 同一个地址，因为请求方式不一样，实现不一样的功能… 此类操作，我们可以基于Express中的路由来完成 1、我们创建一个routers文件夹，在这个文件夹中存储所有功能模块的接口信息（分类存储） 2、在每一个路由模块中完成API接口的编写（举例：user模块）12345678910111213let express = require('express'), router = express.Router();//=&gt;router和app其实差不多router.use((req, res, next)=&gt; &#123; console.log(`ok`); next();&#125;);router.post(`/signin`, (req, res)=&gt; &#123; res.send('login success');&#125;);router.post(`/signup`, (req, res)=&gt; &#123; res.send('register success');&#125;);module.exports = router;//=&gt;把创建的路由导出,方便后续调取使用 3、在server中需要调取使用1234let express = require('express'), app = express();...app.use(`/user`, require('./routers/user')); Express中获取客户端传递的信息 客户端把信息传递给服务器：1、问号传参（GET请求）2、设置请求主体（POST请求）3、设置请求头（cookie等信息传送）… 问号传参 &amp; 请求头12345app.get(`/query`, (req, res)=&gt; &#123; console.log(req.headers);//=&gt;通过REQ的HEADERS可以直接的获取请求头信息(想获取其中的某一个:REQ.HEADERS.HOST...) res.send(req.query);//=&gt;通过REQ中的QUERY就可以获取问号传递的参数值(并且存储的方式是KEY:VALUE)&#125;); 请求主体123456789101112131415161718192021//=&gt;基于传统的内置模块自己实现app.use(`/reg`, (req, res, next)=&gt; &#123; //=&gt;POST请求获取请求主体内容,需要基于事件完成 let str = ``; req.on('data', chunk=&gt; &#123; //=&gt;正在接收请求主体中的内容(一般内容偏多) str += chunk; &#125;); req.on('end', ()=&gt; &#123; //=&gt;接收结束,此时STR存储的就是传递进来的信息 //=&gt;客户端传递给服务器的信息一般都是字符串格式的(JSON字符串或者普通的FORMAT-DATA字符串[xxx=xxx&amp;xxx=xxx]) //=&gt;真实项目中我们还要把字符串转化为对象方式(方便操作) let data = require('querystring').parse(str);//=&gt;这个内置模块就是把FORMAT-DATA变为对象键值对的方式存储 req.body = data;//=&gt;把解析后的数据放到REQ的自定义属性上,在其它的方法中可以获取使用 next(); &#125;);&#125;);app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;); 这种方式太麻烦了，我们可以使用第三方插件搞定刚才处理的事情：body-parser12345678let bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(bodyParser.json());app.use(bodyParser.raw());app.use(bodyParser.text());app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;); Express中静态文件的处理 基于express.static方法即可完成12345678910111213141516171819202122232425let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;真实项目中,我们一般都静态资源文件(HTML/CSS/JS/IMG...)存放在DIST或者LIB或者PUBLIC或者BUILD等指定的文件夹中app.use(express.static('dist'));//=&gt;大体实现原理let fs = require('fs'), path = require('path');let expressStatic = p=&gt; (req, res, next)=&gt; &#123; let pathname = path.join(`$&#123;__dirname&#125;/$&#123;p&#125;`, req.path); fs.readFile(pathname, (err, data)=&gt; &#123; if (err) &#123; //=&gt;找不到指定的文件 next(); &#125; else &#123; //=&gt;找到文件 res.sendFile(pathname); &#125; &#125;);&#125;;app.use(expressStatic('dist'));","categories":[{"name":"Express","slug":"Express","permalink":"http://zhangjuntao.com.cn/categories/Express/"}],"tags":[{"name":"Express NODE","slug":"Express-NODE","permalink":"http://zhangjuntao.com.cn/tags/Express-NODE/"}]}]}